# backend/main.py
import json
import logging
import requests
from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import pytesseract
from pdf2image import convert_from_bytes
import PyPDF2
from io import BytesIO
from typing import Optional, List, Dict
import ollama
from PIL import Image
import re

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="PDF PO Extractor", version="2.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

class Item(BaseModel):
    part_number: Optional[str] = None
    description: Optional[str] = None
    quantity: Optional[str] = None
    unit_price: Optional[str] = None
    amount: Optional[str] = None
    ship_date: Optional[str] = None

class ExtractionResult(BaseModel):
    po_number: Optional[str] = None
    po_date: Optional[str] = None
    delivered_to: Optional[str] = None
    shipped_to: Optional[str] = None
    vendor_code: Optional[str] = None
    vendor_ref: Optional[str] = None
    ship_via: Optional[str] = None
    ordered_by: Optional[str] = None
    terms: Optional[str] = None
    items: List[Item] = []
    total_without_tax: Optional[str] = None
    tax: Optional[str] = None
    tps: Optional[str] = None
    tvq: Optional[str] = None
    total_with_tax: Optional[str] = None

def extract_text_from_file(file: UploadFile) -> str:
    logger.info(f"Extracting text from file: {file.filename}")
    try:
        file_content = file.file.read()
        
        if file.filename.lower().endswith('.pdf'):
            try:
                with BytesIO(file_content) as pdf_file:
                    reader = PyPDF2.PdfReader(pdf_file)
                    text = "\n".join([page.extract_text() for page in reader.pages])
                    if text.strip():
                        logger.info("Text extracted directly from PDF")
                        return text
            except Exception as e:
                logger.warning(f"Direct PDF extraction failed: {str(e)}, falling back to OCR")
            
            images = convert_from_bytes(file_content)
            text = "\n".join([pytesseract.image_to_string(img) for img in images])
            logger.info("Text extracted via OCR")
            return text
        
        image = Image.open(BytesIO(file_content))
        text = pytesseract.image_to_string(image)
        logger.info("Text extracted from image")
        return text
    
    except Exception as e:
        logger.error(f"File processing error: {str(e)}")
        raise HTTPException(status_code=400, detail=f"Erreur de traitement du fichier: {str(e)}")

def clean_llm_response(response: str) -> Dict:
    logger.info("Cleaning LLM response")
    try:
        response = response.replace("```json", "").replace("```", "")
        start = response.find('{')
        end = response.rfind('}') + 1
        json_str = response[start:end]
        json_str = re.sub(r'(?<!\\)\\(?!["\\/bfnrt]|u[0-9a-fA-F]{4})', r'', json_str)
        data = json.loads(json_str)
        
        # Convertir les listes contenant une seule valeur en cha√Ænes
        for key, value in data.items():
            if isinstance(value, list) and len(value) == 1 and key != "items":
                data[key] = value[0]
            elif isinstance(value, list) and key != "items":
                data[key] = " ".join(str(v) for v in value)  # Concat√©ner si plusieurs valeurs
        return data
    except Exception as e:
        logger.error(f"JSON parsing error: {str(e)} - Response: {response}")
        raise HTTPException(status_code=500, detail=f"Erreur de parsing JSON: {str(e)} - R√©ponse: {response}")

def check_ollama_health():
    try:
        response = requests.get("http://127.0.0.1:11434", timeout=5)
        if response.status_code != 200:
            raise Exception(f"Ollama responded with status {response.status_code}")
        logger.info("Ollama service is healthy")
    except requests.RequestException as e:
        logger.error(f"Ollama health check failed: {str(e)}")
        raise HTTPException(status_code=503, detail="Service Ollama indisponible. Veuillez d√©marrer Ollama avec 'ollama serve'.")

def call_llm(text: str) -> ExtractionResult:
    logger.info("Calling LLM for text analysis")
    check_ollama_health()
    
    prompt = """Analyse ce document de commande (PO) en fran√ßais ou anglais et extrais les informations suivantes au format JSON.

Texte du document:
{texte_source}

Instructions:
1. Recherche les champs suivants (fran√ßais ou anglais):
   - Num√©ro PO (Numero / Number)
   - Date PO (Date)
   - Livr√© √† (Livrer a / Delivered to)
   - Exp√©di√© √† (Expedie a / Shipped to)
   - Code fournisseur (Code du fournisseur / Vendor code)
   - R√©f√©rence fournisseur (Ref. fournisseur / Vendor ref)
   - Exp√©di√© par (Expedie par / Ship via)
   - √âmis par (Emis par / Ordered by)
   - Termes (Terms)
   - Items (avec: Num√©ro pi√®ce/Part number, Description, Quantit√©/Qty, Prix unitaire/Unit price, Montant/Amount, Date livraison/Ship date)
   - Total sans taxe (Total PO sans taxe / Total without tax)
   - Taxe (Taxe / Tax)
   - TPS (TPS)
   - TVQ (TVQ)
   - Total avec taxe (Total avec taxe / Total with tax)
2. Pour les dates, utilise le format AAAA/MM/JJ
3. Pour les prix, conserve TOUS les chiffres (pas d'arrondi) avec la devise si pr√©sente
4. Pour les articles, liste tous les √©l√©ments trouv√©s dans une liste 'items'
5. TOUS les champs (sauf 'items') doivent √™tre des cha√Ænes de caract√®res (string), PAS des listes
6. Retourne UNIQUEMENT un JSON valide avec cette structure:
{{
    "po_number": "string | null",
    "po_date": "string | null",
    "delivered_to": "string | null",
    "shipped_to": "string | null",
    "vendor_code": "string | null",
    "vendor_ref": "string | null",
    "ship_via": "string | null",
    "ordered_by": "string | null",
    "terms": "string | null",
    "items": [
        {{
            "part_number": "string | null",
            "description": "string | null",
            "quantity": "string | null",
            "unit_price": "string | null",
            "amount": "string | null",
            "ship_date": "string | null"
        }}
    ],
    "total_without_tax": "string | null",
    "tax": "string | null",
    "tps": "string | null",
    "tvq": "string | null",
    "total_with_tax": "string | null"
}}""".format(texte_source=text[:15000])

    try:
        response = ollama.generate(
            model="mistral",
            prompt=prompt,
            options={
                "temperature": 0.1,
                "num_ctx": 4096
            }
        )
        logger.info("LLM response received")
        
        json_data = clean_llm_response(response['response'])
        
        result = ExtractionResult(
            po_number=json_data.get("po_number"),
            po_date=json_data.get("po_date"),
            delivered_to=json_data.get("delivered_to"),
            shipped_to=json_data.get("shipped_to"),
            vendor_code=json_data.get("vendor_code"),
            vendor_ref=json_data.get("vendor_ref"),
            ship_via=json_data.get("ship_via"),
            ordered_by=json_data.get("ordered_by"),
            terms=json_data.get("terms"),
            total_without_tax=json_data.get("total_without_tax"),
            tax=json_data.get("tax"),
            tps=json_data.get("tps"),
            tvq=json_data.get("tvq"),
            total_with_tax=json_data.get("total_with_tax")
        )
        
        for item in json_data.get("items", []):
            result.items.append(Item(**item))
        
        logger.info("Extraction result prepared")
        return result
        
    except ollama.ResponseError as e:
        logger.error(f"Ollama response error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur de r√©ponse Ollama: {str(e)}")
    except Exception as e:
        logger.error(f"LLM processing error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur du mod√®le LLM: {str(e)}. V√©rifiez que le mod√®le 'mistral' est charg√© et que Ollama est en marche.")

@app.post("/extract", response_model=ExtractionResult)
async def extract_infos(file: UploadFile = File(...)):
    logger.info("Received extract request")
    try:
        text = extract_text_from_file(file)
        return call_llm(text)
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Unexpected error in extract_infos: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erreur inattendue: {str(e)}")

@app.get("/health")
async def health_check():
    try:
        check_ollama_health()
        return {"status": "healthy", "model": "mistral"}
    except HTTPException as e:
        raise e

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)





# une autre prompt que gpt ma proposer 




# def call_llm(text: str) -> ExtractionResult:
#     logger.info("Calling LLM for text analysis")
#     check_ollama_health()

#     prompt = f"""
# Tu es un expert en traitement de documents d'achat (bons de commande / purchase orders) en fran√ßais et en anglais. √Ä partir du texte ci-dessous, tu dois extraire les informations cl√©s et retourner un JSON strictement conforme au format demand√©.

# ---------------------
# üìÑ Texte du document :
# {text[:15000]}
# ---------------------

# üéØ Objectif : Extraire les informations suivantes (si pr√©sentes) :

# - "po_number" : Num√©ro du bon de commande (ex: 2203)
# - "po_date" : Date de la commande (ex: "06 Nov 2012" ‚Üí "2012/11/06")
# - "delivered_to" : Adresse compl√®te de livraison
# - "shipped_to" : Adresse exp√©di√©e √† (souvent m√™me chose que livraison)
# - "vendor_code" : Code fournisseur (ex: M0062)
# - "vendor_ref" : R√©f√©rence fournisseur (ex: REF-45678)
# - "ship_via" : Mode d'exp√©dition (ex: FedEx, Pickup, etc.)
# - "ordered_by" : Personne ou service ayant √©mis la commande
# - "terms" : Conditions de paiement
# - "items": Liste d'articles avec les champs suivants :
#   - "part_number" : Num√©ro de pi√®ce ou mat√©riel (ex: MC695-005-11)
#   - "description" : Description de l‚Äôarticle
#   - "quantity" : Quantit√© (ex: 2, 12.5, 100 pcs, etc.)
#   - "unit_price" : Prix unitaire avec devise (ex: $125.50)
#   - "amount" : Montant total de la ligne (ex: $251.00)
#   - "ship_date" : Date de livraison pr√©vue (ex: 07 Nov 2012 ‚Üí 2012/11/07)
# - "total_without_tax" : Total HT (avant taxes)
# - "tax" : Montant total de la taxe si disponible
# - "tps" : Montant de la TPS (Canada)
# - "tvq" : Montant de la TVQ (Qu√©bec)
# - "total_with_tax" : Total TTC

# üìù Instructions importantes :
# 1. Le JSON retourn√© doit √™tre **valide, sans texte en dehors de la structure JSON**.
# 2. Convertis toutes les **dates au format AAAA/MM/JJ** (ex: "7 Nov 2012" ‚Üí "2012/11/07").
# 3. Si un champ est absent ou non explicite, retourne `null`.
# 4. Tous les montants doivent **conserver la devise** si elle est pr√©sente (ex: "$12.56", "CAD 9,10", etc.)
# 5. N‚Äôinvente pas d‚Äôinformations. Prends la premi√®re valeur logique si plusieurs apparaissent.
# 6. Tous les champs doivent √™tre des cha√Ænes de caract√®res sauf "items" (liste de dictionnaires).

# üì¶ Exemple attendu :
# {{
#   "po_number": "2203",
#   "po_date": "2012/11/06",
#   "delivered_to": "Mindcore Technologies, 1845 Jean-Monnet, Terrebonne, QC J6X 4L7, Canada",
#   "shipped_to": "USINAGE TOURMAC INC., 11 rue de l'Industrie, St-R√©mi, QC J0L 2L0, Canada",
#   "vendor_code": "M0062",
#   "vendor_ref": null,
#   "ship_via": "Pickup",
#   "ordered_by": "Julie Robidoux",
#   "terms": "Net 30",
#   "items": [
#     {{
#       "part_number": "COPIB187C110287523150280-288",
#       "description": "Copper Tube B187C110 2-1/2'' Schedule 80 √ó 288''",
#       "quantity": "2",
#       "unit_price": "$701.09",
#       "amount": "$1,402.18",
#       "ship_date": "2012/11/07"
#     }}
#   ],
#   "total_without_tax": "$1,402.18",
#   "tax": "$210.33",
#   "tps": "$70.10",
#   "tvq": "$140.23",
#   "total_with_tax": "$1,612.51"
# }}
# """

#     try:
#         response = ollama.generate(
#             model="mistral",
#             prompt=prompt,
#             options={
#                 "temperature": 0.1,
#                 "num_ctx": 4096
#             }
#         )
#         logger.info("LLM response received")

#         json_data = clean_llm_response(response['response'])

#         result = ExtractionResult(
#             po_number=json_data.get("po_number"),
#             po_date=json_data.get("po_date"),
#             delivered_to=json_data.get("delivered_to"),
#             shipped_to=json_data.get("shipped_to"),
#             vendor_code=json_data.get("vendor_code"),
#             vendor_ref=json_data.get("vendor_ref"),
#             ship_via=json_data.get("ship_via"),
#             ordered_by=json_data.get("ordered_by"),
#             terms=json_data.get("terms"),
#             total_without_tax=json_data.get("total_without_tax"),
#             tax=json_data.get("tax"),
#             tps=json_data.get("tps"),
#             tvq=json_data.get("tvq"),
#             total_with_tax=json_data.get("total_with_tax")
#         )

#         for item in json_data.get("items", []):
#             result.items.append(Item(**item))

#         logger.info("Extraction result prepared")
#         return result

#     except ollama.ResponseError as e:
#         logger.error(f"Ollama response error: {str(e)}")
#         raise HTTPException(status_code=500, detail=f"Erreur de r√©ponse Ollama: {str(e)}")
#     except Exception as e:
#         logger.error(f"LLM processing error: {str(e)}")
#         raise HTTPException(status_code=500, detail=f"Erreur du mod√®le LLM: {str(e)}. V√©rifiez que le mod√®le 'mistral' est bien en cours d'ex√©cution via 'ollama serve'.")